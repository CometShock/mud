import { CollapseCode } from "../../../components/CollapseCode";

# Hooks

In this tutorial you add a contract that is called when the counter is modified, and ensures that the counter is always a single digit number.
This demonstrates how you can use hooks to ensure data integrity, respond to changes in the data regardless of which system caused them, etc.

Here we build a hook that is called when the counter is incremented.
If the counter is still less than ten, the hook does nothing.
If the counter is a higher value, the hook calls `IncrementSystem` to reset the counter back to zero.

## Update and create files

1.  Add a `resetCounter` function to `IncrementSystem`.
    We need to add this here, because by default hooks are allowed to read tables from the `World`, but not to modify them.

       <CollapseCode>

    ```solidity filename="packages/contracts/src/systems/IncrementSystem.sol" showLineNumbers copy {15-18}
    // SPDX-License-Identifier: MIT
    pragma solidity >=0.8.0;

    import { System } from "@latticexyz/world/src/System.sol";
    import { Counter } from "../codegen/Tables.sol";

    contract IncrementSystem is System {
      function increment() public returns (uint32) {
        uint32 counter = Counter.get();
        uint32 newValue = counter + 1;
        Counter.set(newValue);
        return newValue;
      }

      function counterReset() public returns (uint32) {
        Counter.set(0);
        return 0;
      }
    }
    ```

       </CollapseCode>

1.  Create a contract with the functions to `hang` on the hooks.
    Implementing `IStoreHook` requires four functions:

    - `onBeforeSetField`, which is called before a specific field is set.
    - `onAfterSetField`, which is called after a specific field is set.
    - `onDeleteRecord`, which is called when a record is deleted.
      This hook is not relevant here, because the `Counter` table is a singleton so records are never created or deleted.
    - `onSetRecord`, which is called when a new record is created or when the entire record is set with a single call.
      This hook is not relevant here, because the `Counter` table is a singleton.

    Note that MUD called either `onSetRecord` (before the change) or both `onBeforeSetField` and `onAfterSetField`.
    Therefore, if you do any sanity checks when the table values change, they should happen in both places.

    ```solidity filename="packages/contracts//src/hooks/CounterHook.sol" showLineNumbers copy
    // SPDX-License-Identifier: MIT
    pragma solidity >=0.8.0;

    import { IStoreHook } from "@latticexyz/store/src/IStore.sol";
    import { Counter } from "../codegen/Tables.sol";
    import { IWorld } from "../codegen/world/IWorld.sol";

    contract CounterHook is IStoreHook {
      IWorld world;
      bool internal locked = false;

      modifier notReentrant() {
        if (locked) return;

        locked = true;
        _;
        locked = false;
      }

      constructor(address worldAddr) {
        world = IWorld(worldAddr);
      }

      function onBeforeSetField(
        bytes32 table,
        bytes32[] memory key,
        uint8 schemaIndex,
        bytes memory data
      ) external notReentrant {
        return;
      }

      function onAfterSetField(
        bytes32 table,
        bytes32[] memory key,
        uint8 schemaIndex,
        bytes memory data
      ) external notReentrant {
        uint32 counter = Counter.get();
        if (counter > 9) {
          world.counterReset();
        }
      }

      function onDeleteRecord(bytes32 table, bytes32[] memory key) external notReentrant {
        revert("onDeleteRecord");
      }

      function onSetRecord(bytes32 table, bytes32[] memory key, bytes memory data) external notReentrant {
        revert("onSetRecord");
      }
    }
    ```

<details>
<summary>Explanation</summary>

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import { IStoreHook } from "@latticexyz/store/src/IStore.sol";
```

[`IStoreHook`]()https://github.com/latticexyz/mud/blob/main/packages/store/src/IStore.sol#L131-L152 is the interface that hooks need to implement.

```solidity
import { Counter } from "../codegen/Tables.sol";
import { IWorld } from "../codegen/world/IWorld.sol";

contract CounterHook is IStoreHook {
    IWorld world;
```

The `World` to which we are connected.
We need this information because hooks cannot change information, so if we want to reset the counter we need to go through the `IncrementSystem` logic.

Note that this is _not_ the common use case for hooks.
In most cases, you just `revert()` when a change is not allowed, which is a lot simpler.
However, modifying the value to a legitimate one is more complicated and error prone, so it is worth learning how to do it correctly.

```solidity
    bool internal locked = false;
```

Code that isn't written for [reentrancy](<https://en.wikipedia.org/wiki/Reentrancy_(computing)>) can suffer from [serious problems](https://www.quicknode.com/guides/ethereum-development/smart-contracts/a-broad-overview-of-reentrancy-attacks-in-solidity-contracts).
If we trigger a value change while in the middle of a value change, the second value change will also trigger its own hook call.
This could lead to an infinite loop, which will only terminate once it uses up all the gas of the transaction, which will fail, or worse to unexpected effects that could compromise security.

We use `locked` here to detect reentrancy.
We can use a single boolean value because the `Counter` table is a singleton.
In a more complicated table we would need to use a [`mapping`](https://www.tutorialspoint.com/solidity/solidity_mappings.htm) to lock specific records rather than the entire table.

```solidity
    modifier notReentrant() {
```

[Modifiers](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm) are a type of Solidity function that modifies a normal contract function.
They can include code that runs immediately before the function being modified, and code that runs immediately after it.

```solidity
        if (locked) return;
```

If `locked` is `true` then return immediately and don't do anything.
This is the correct behavior in this case because we want hook functions that are called during a state change to accept the change.
If we were to revert then the entire transaction would fail.

```solidity
        locked = true;
        _;
        locked = false;
    }
```

1. Set `locked` to `true`, and then run the function being modified.
   Because `locked` is `true`, if we get to `notReentrant` again it will just return.

1. The syntax `_;` runs the function being modified.

1. Once we are done, set `locked` to `false`.

```solidity
constructor(address worldAddr) {
  world = IWorld(worldAddr);
}
```

Set `world`. We need this information to be able to call `counterReset` as needed.

```solidity
    function onBeforeSetField(
```

All four hooks have very similar parameters:

```solidity
        bytes32 table,
```

The 32 byte table identitier.
16 bytes for the namespace followed by 16 bytes for the table name.
The same hook contract can be used for multiple tables.

```solidity
        bytes32[] memory key,
```

The key of the entry being modified.
Keys in MUD can include multiple fields, each represented by a `byte32` value.
Of course, because `Counter` is a singleton, here it would always be zero.

```solidity
        uint8 schemaIndex,
```

The index of the field being modified in the schema.
This parameter is only relevant to `onBeforeSetField` and `onAfterSetField`, so it does not appear in the the whole record functions (`onDeleteRecord` and `onSetRecord`).

```solidity
        bytes memory data
```

The field data.
It is `bytes memory` because different field types have different lengths.

```solidity
    ) external notReentrant {
```

This is how you use a modifier, such as `notReentrant`, you put it at the end of the function signature, just before the code block.

```solidity
        return;
    }
```

In this case there isn't anything we do in the hook, so we just return.
Note that we don't really need `nonReentrant` here, because we don't do anything, but it is still safer to have it in case we need to add functionality here in the future and forget.

```solidity
    function onAfterSetField(
        bytes32 table,
        bytes32[] memory key,
        uint8 schemaIndex,
        bytes memory data
    ) external notReentrant {
        uint32 counter = Counter.get();
```

Read the value of `Counter`.
We could have parsed the value from `data`, this method is just more readable.

```solidity
        if (counter > 9) {
            world.counterReset();
        }
    }
```

If the value is above nine, call `world.counterReset()` to move it back to zero.

```solidity
    function onDeleteRecord(bytes32 table, bytes32[] memory key) external notReentrant {
        revert("onDeleteRecord");
    }

    function onSetRecord(bytes32 table, bytes32[] memory key, bytes memory data)  external notReentrant {
        revert("onSetRecord");
    }
}
```

These two hooks should not be called, so as a sanity check we `revert` so it will be visible if they are called for some reason.

</details>

3. Update the post deploy script.
   In Foundry we deploy code to the blockchain using [Solidity scripts](https://book.getfoundry.sh/tutorials/solidity-scripting).
   Here we need to perform two additional actions:

   1. Deploy the `CounterHook` contract (line 27).
      The constructor to this contract requires us to provide the `World` address.
   1. Register the new `CounterHook` contract as the hook contract for the `Counter` table (line 28).

   <CollapseCode>

   ```solidity filename="packages/contracts/scripts/IncrementSystem.sol" showLineNumbers copy {8-9,21-28}
   // SPDX-License-Identifier: MIT
   pragma solidity >=0.8.0;

   import { Script } from "forge-std/Script.sol";
   import { console } from "forge-std/console.sol";
   import { IWorld } from "../src/codegen/world/IWorld.sol";

   import { CounterTableId } from "../src/codegen/Tables.sol";
   import { CounterHook } from "../src/hooks/CounterHook.sol";

   contract PostDeploy is Script {
     function run(address worldAddress) external {
       // Load the private key from the `PRIVATE_KEY` environment variable (in .env)
       uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");

       // Start broadcasting transactions from the deployer account
       vm.startBroadcast(deployerPrivateKey);

       // ------------------ EXAMPLES ------------------

       IWorld world = IWorld(worldAddress);

       // Call increment on the world via the registered function selector
       uint32 newValue = world.increment();
       console.log("Increment via IWorld:", newValue);

       CounterHook hook = new CounterHook(worldAddress);
       world.registerTableHook(bytes16(CounterTableId), bytes16(uint128(uint256(CounterTableId))), hook);

       vm.stopBroadcast();
     }
   }
   ```

   </CollapseCode>

<details>
<summary>Explanation</summary>

```solidity
import { CounterTableId } from "../src/codegen/Tables.sol";
import { CounterHook } from "../src/hooks/CounterHook.sol";
```

```solidity
IWorld world = IWorld(worldAddress);
```

We need the world address twice, so we'll just store it in a variable.

```solidity
// Call increment on the world via the registered function selector
uint32 newValue = world.increment();
console.log("Increment via IWorld:", newValue);

CounterHook hook = new CounterHook(worldAddress);
```

Deploy the `CounterHook` contract.

```solidity
world.registerTableHook(bytes16(CounterTableId), bytes16(uint128(uint256(CounterTableId))), hook);
```

Register the `CounterHook` contract.

</details>
