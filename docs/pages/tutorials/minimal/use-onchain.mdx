# Use MUD from onchain code

In this tutorial you learn how to use a `World` and the systems in it from code that runs on the blockchain.
You can use this knowledge to add sub-systems to a `World` or to use MUD as part of a bigger dapp.

## Setup

[Create a minimal application](../minimal) and run it.

## Use the `World` from Foundry

As a first step, we can access the `World` from Foundry.
This is the easiest method to experiment.

1. Set some variables.
   This is assuming you are running the minimal application locally through `pnpm dev` and have not modified any contracts.
   If that is not correct in your case modify as needed.

   ```sh copy
   export ETH_RPC_URL=http://localhost:8545
   WORLD_ADDR=0x5FbDB2315678afecb367f032d93F642f64180aa3
   PRIVATE_KEY=0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6
   ```

   Note that the private key is _not_ [the one used to deploy the `World`](https://github.com/latticexyz/mud/blob/main/templates/vanilla/packages/contracts/.env).
   This is on purpose, to ensure that you can use everything in this tutorial to extend other people's `World`s.

1. View the value of `Counter` on the user interface.

1. Increment the counter.

   ```sh copy
   cast send --private-key $PRIVATE_KEY $WORLD_ADDR "increment()"
   ```

1. View the value of `Counter` on the user interface, see that it was incremented.

<details>

<summary>How do I get the counter value in Foundry?</summary>

The process to get a value directly from a MUD table as an EOA (externally owned account) is a bit complicated.
Normally, we'd expect onchain code to use [the library](https://github.com/latticexyz/mud/blob/main/templates/vanilla/packages/contracts/src/codegen/tables/Counter.sol), but that library is not available on the command line.

If you want to do it anyway, here are the steps.

1. Specify the identifier for the `Counter` table.

   ```sh copy
   COUNTER_TABLE=0x00000000000000000000000000000000436f756e746572000000000000000000
   ```

   The convention (which is not enforced by onchain code) for identifying tables is to have two ASCII strings, one starting in byte 0 (namespace) and one starting in byte 16 (table name).
   The values are then padded with zeros to make them into 16 bytes.

   If the case of `Counter`, the namespace is empty (it is in the root namespace) and the name of the table is `Counter`.
   [You can see the code that calculates that `tableId` in the template](https://github.com/latticexyz/mud/blob/main/templates/vanilla/packages/contracts/src/codegen/tables/Counter.sol#L20-L21).
   You can also use [this calculator](https://www.duplichecker.com/text-to-hex.php) to translate text into ASCII hexadecimal.

1. Get the value schema for `Counter`.

   ```sh copy
   COUNTER_VAL_SCHEMA=`cast call $WORLD_ADDR "getValueSchema(bytes32)" $COUNTER_TABLE`
   ```

   We need to provide the value schema to the function that actually gets the record.
   [You can read the `getValueSchema` function in the source code](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreRead.sol#L13-L15).

1. Read the counter value.

   ```sh copy
   cast call $WORLD_ADDR 'getField(bytes32,bytes32[] calldata,uint8,bytes32)' \
             $COUNTER_TABLE '[]' 0 $COUNTER_VAL_SCHEMA
   ```

   `getField` takes four parameters:

   - The identifier for the table.
   - The array of key values, which in this case is empty.
   - The number of the field we want within the value schema.
     The first field (the only one in `Counter`) is zero.
   - The value schema we got in the previous step.

   [You can also read this function in the source code](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreRead.sol#L30-L38).

   The output is ABI encoded as an array of variable length fields, so it is a bit difficult to read.
   Here it is, divided into 32 byte words.

   | Word | Value                                                                |
   | ---: | -------------------------------------------------------------------- |
   |    0 | 00000000000000000000000000000000000000000000000000000000000000**20** |
   |    1 | 00000000000000000000000000000000000000000000000000000000000000**04** |
   |    2 | **00000006**00000000000000000000000000000000000000000000000000000000 |

   Word 0 tells us that the data starts at byte number 0x20=32, which is word 1.
   Word 1 tells us that the data for the field we care about is four bytes long (the size of `uint32`).
   Word 2 actually gives us the value, padded by zeros to complete the word.

It is much easier for offchain code to just synchronize from [an Indexer](\indexer) and listen for events.

</details>

## Use the `World` from a contract

You can use the contract [in the examples directory](https://github.com/latticexyz/mud/tree/main/examples/onchain-client).

1. Download the source code and install the necessary packages.

   ```sh copy
   git clone https://github.com/latticexyz/mud.git
   cd mud/examples/onchain-client/
   pnpm install
   ```

1. Set the necessary environment variables.

   ```sh copy
   . .env
   ```

   This file specifies two variables:

   | Variable    | Meaning                                                                                                                 |
   | ----------- | ----------------------------------------------------------------------------------------------------------------------- |
   | PRIVATE_KEY | A private key that has ETH on the blockchain. This is a different private key than the one that deployed the `World`.   |
   | WORLD_ADDR  | The address of the `World` contract. The value in `.env` is the initial world deployed by `pnpm dev`, change as needed. |

1. Deploy the sample contact.

   ```sh copy
   forge create OnchainClient --private-key $PRIVATE_KEY --constructor-args $WORLD_ADDR
   ```

1. Set `CLIENT_ADDR` to the address to which the contract is deployed.

1. Get the value of `Counter` from the client.

   ```sh copy
   cast call $CLIENT_ADDR "readCounter()"
   ```

1. Increment `Counter` and read the value again.
   See it is one more.

   ```sh copy
   cast send --private-key $PRIVATE_KEY $CLIENT_ADDR "add1()"
   cast call $CLIENT_ADDR "readCounter()"
   ```

1. Attempt to reset the counter, which bypasses the `System` logic and modifies `Counter` directly.
   See that this attempt fails.

   ```sh copy
   cast send --private-key $PRIVATE_KEY $CLIENT_ADDR "reset()"
   ```

   The error message should be similar to:

   ```
   (code: 3, message: execution reverted, data: Some(String("0x")))
   ```

<details>

<summary>Explanation of `src/OnchainClient.sol`</summary>

Let's go over the contract source code (`src/OnchainClient.sol`).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import { Counter } from "codegen/Tables.sol";
import { IWorld } from "codegen/world/IWorld.sol";
```

We import `Counter` and `IWorld` from the code that was generated using `mud codegen`.
The entire `src/codegen` directory is copied [from the template](https://github.com/latticexyz/mud/tree/main/templates/vanilla/packages/contracts/src/codegen) into the new application's `lib` directory.

```solidity
contract OnchainClient {
  IWorld immutable world;

  constructor(address world_) {
    world = IWorld(world_);
  }
```

Define a variable to hold the address of the `World`.
The constructor receives the value for it.

```solidity
function readCounter() public view returns (uint32) {
  return Counter.get(world);
}
```

To get the value of the counter we use the `Counter` library we imported from `codegen/Tables.sol`.
There are two versions of `get` in that library.

[This version](https://github.com/latticexyz/mud/blob/230822-use-onchain/examples/onchain-client/lib/codegen/tables/Counter.sol#L60-L66) reads from the `World` of which it is a part.
It is the version you use in a `System` deployed to that `World`.

[This version](https://github.com/latticexyz/mud/blob/230822-use-onchain/examples/onchain-client/lib/codegen/tables/Counter.sol#L68-L74) gets a parameter which is the address of the `World`.
It is the version you use in code which is not part of the `World` with the relevant table.

```
  function add1() public {
    world.increment();
  }
```

When a `System` is in the root namespace of a `World`, its functions are available from the `World` itself.
This is the way to activate the logic in a `System`.

```
  function reset() public {
    Counter.set(world, 0);
  }
}
```

This function attempts to bypass the `System` logic and set the counter value directly.
As you have already seen, it fails.

</details>

<details>

<summary>Setting up a Foundry project for MUD access</summary>

The example is already set up for MUD access, but these are the steps you do to add it to other Foundry projects.

1. Create the Foundry project.

   ```sh copy
   forge init
   ```

1. Copy the `src/codegen` directory into `lib`.

1. At the root of the Foundry project, create a Node project for the libraries (Solidity libraries are usually published as [npm packages](https://www.npmjs.com/) and ours are no exception).

   ```sh copy
   pnpm init
   pnpm install @latticexyz/world@next @latticexyz/store@next @latticexyz/schema-type@next
   ```

1. Create a remapping file to inform Foundry where the MUD libraries are located.

   ```text filename="remappings.txt" copy
   @latticexyz=node_modules/@latticexyz
   ```

</details>
