# Use MUD from onchain code

In this tutorial you will learn how to use a `World` and the systems in it from Solidity code (via forge scripts in your command line or via deployed contracts).
You can use this knowledge to add sub-systems to a `World` or to access MUD state in contracts outside the `World`.

## Setup

1. [Create a minimal application](../minimal) and run it.
   This creates and deploys a `World` onchain for us to interact with.

1. In a separate command line window, clone the MUD repository and install the necessary packages to run the `onchain-client` example project.

   ```sh copy
   git clone https://github.com/latticexyz/mud.git
   cd mud/examples/onchain-client/
   pnpm install
   ```

1. Set the necessary environment variables in `.env`. This file specifies two variables:

   | Variable      | Meaning                                                                                                                 |
   | ------------- | ----------------------------------------------------------------------------------------------------------------------- |
   | PRIVATE_KEY   | A private key that has ETH on the blockchain. This is a different private key than the one that deployed the `World`.   |
   | WORLD_ADDRESS | The address of the `World` contract. The value in `.env` is the initial world deployed by `pnpm dev`, change as needed. |

   If these values need to be different from the default ones, edit `.env` appropriately.

1. Run the MUD codegen to generate table libraries and World interfaces from your MUD config.

   ```sh copy
   pnpm build:mud
   ```

<details>

<summary>Generating MUD code</summary>

The definitions for this `World` are contained in two files:

- [`mud.config.ts` which contains the data schema](/tutorials/walkthrough/minimal-onchain#mudconfigts).
- [`src/systems/IncrementSystem.sol`](https://mud.dev/tutorials/walkthrough/minimal-onchain#incrementsystemsol).
  This file is used to generate the Solidity code for `IIncrementSystem` and `IWorld`.
  It does not need the actual logic, that is already onchain, just the function definitions.

When we run `pnpm build:mud`, MUD generates the files in `src/codegen` that represent this `World` in Solidity.
You can read a description of the resulting data definitions [in the onchain walkthrough](/tutorials/walkthrough/minimal-onchain) (expand **The autogenerated files**).
The `World` definition in `src/codegen/world/IWorld.sol` simply tells other Solidity files about the functions that are included in the `World`, including `increment`.

</details>

## Use the `World` from a contract

You can use the contract [in the examples directory](https://github.com/latticexyz/mud/tree/main/examples/onchain-client).

1. Read the environment variables.

   ```sh copy
   . ./.env
   ```

1. Deploy the sample contact.

   ```sh copy
   forge create OnchainClient --private-key $PRIVATE_KEY --constructor-args $WORLD_ADDRESS
   ```

1. Set `CLIENT_ADDRESS` to the address to which the contract is deployed.

1. Get the value of `Counter` from the client.

   ```sh copy
   cast call $CLIENT_ADDRESS "readCounter()"
   ```

1. Increment `Counter` and read the value again.
   See it is one more.

   ```sh copy
   cast send --private-key $PRIVATE_KEY $CLIENT_ADDRESS "add1()"
   cast call $CLIENT_ADDRESS "readCounter()"
   ```

1. Attempt to reset the counter, which bypasses the `System` logic and modifies `Counter` directly.
   See that this attempt fails, since our contract doesn't have the necessary access rights to write to the `Counter` table.

   ```sh copy
   cast send --private-key $PRIVATE_KEY $CLIENT_ADDRESS "reset()"
   ```

   The error message should be similar to:

   ```
   (code: 3, message: execution reverted, data: Some(String("0x")))
   ```

<details>

<summary>Explanation of `src/OnchainClient.sol`</summary>

Let's go over the contract source code (`src/OnchainClient.sol`).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import { Counter } from "codegen/Tables.sol";
import { IWorld } from "codegen/world/IWorld.sol";
```

We import `Counter` and `IWorld` from the code that was generated using `mud codegen`.

```solidity
contract OnchainClient {
  IWorld immutable world;

  constructor(address world_) {
    world = IWorld(world_);
  }
```

Define a variable to hold the address of the `World`.
The constructor receives the value for it.

```solidity
function readCounter() public view returns (uint32) {
  return Counter.get(world);
}
```

To get the value of the counter we use the `Counter` library we imported from `codegen/Tables.sol`.
There are two versions of `get` in that library.

[This version](https://github.com/latticexyz/mud/blob/230822-use-onchain/examples/onchain-client/src/codegen/tables/Counter.sol#L60-L66) reads from the `World` of which it is a part.
It is the version you use in a `System` deployed to that `World`.

[This version](https://github.com/latticexyz/mud/blob/230822-use-onchain/examples/onchain-client/src/codegen/tables/Counter.sol#L68-L74) gets a parameter which is the address of the `World`.
It is the version you use in code which is not part of the `World` with the relevant table.

```solidity
function add1() public {
  world.increment();
}
```

When a `System` is in the root namespace of a `World`, its functions are available from the `World` itself, so we can call the function on the `World` to execute the `System` logic.

```solidity
  function reset() public {
    Counter.set(world, 0);
  }
}
```

This function attempts to bypass the `System` logic and set the counter value directly.
As you have already seen, it fails because the contract doesn't have the necessary access rights to write to the `Counter` table.

</details>
