# The onchain components of the template

You [installed the template code](/quick-start), and now you can increment the counter with the best of them.
Unfortunately, when you tried to figure out what is happening, it is as clear as mud.
Have no fear, in this tutorial you learn how to understand the onchain components of the minimal template.

The onchain components are stored in `packages/contracts`.
The onchain components can be divided into two types of functionality:

- **Data**, the part of the system that stores the information.
- **Logic**, the part of the system that can be called to read or modify the data.

## Data

### The data schema

#### `mud.config.ts`

The data schema is declared in `packages/contracts/mud.config.ts`.
[Read more details about the schema definition here](/world/config#global-configuration-keys).

```ts filename="mud.config.ts" copy showLineNumbers
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
  tables: {
    Counter: {
      keySchema: {},
      valueSchema: "uint32",
    },
  },
});
```

This definition is roughly equivalent to this Solidity code:

```solidity
contract Example {
  uint32 Counter;
}
```

If you are running `pnpm dev` the data schema is updated automatically.
Otherwise, run this command.

```sh copy
cd packages/contracts
pnpm mud tablegen
cd ../..
```

When you update the schema, you get these files (one for each table and one that imports the definitions from them):

- `packages/contracts/src/codegen/index.sol`
- `packages/contracts/src/codegen/tables/Counter.sol`

Click below for an explanation of these files.

<details>
<summary>The autogenerated files</summary>
  
#### `index.sol`

```solidity filename="index.sol"
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/* Autogenerated file. Do not edit manually. */

import { Counter, CounterTableId } from "./tables/Counter.sol";
```

This file just imports the definitions of all the tables defined in the schema.

#### `Counter.sol`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.21;

/* Autogenerated file. Do not edit manually. */

// Import schema type
import { SchemaType } from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { FieldLayout, FieldLayoutLib } from "@latticexyz/store/src/FieldLayout.sol";
import { Schema, SchemaLib } from "@latticexyz/store/src/Schema.sol";
import { PackedCounter, PackedCounterLib } from "@latticexyz/store/src/PackedCounter.sol";
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";
import { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from "@latticexyz/store/src/storeResourceTypes.sol";
```

These are various definitions required for a mud table.
You don't typically need to worry about them.

```solidity
ResourceId constant _tableId = ResourceId.wrap(
  bytes32(abi.encodePacked(RESOURCE_TABLE, bytes14(""), bytes16("Counter")))
);
ResourceId constant CounterTableId = _tableId;
```

One advantage of mud is that the metadata, the information that describes the data we are managing, is available onchain.
For table IDs the first two characters are an identifier, followed by fourteen characters for the namespace of the table, and then sixteen characters for the name of the table itself.
The root namespace is empty.

```solidity
FieldLayout constant _fieldLayout = FieldLayout.wrap(
  0x0004010004000000000000000000000000000000000000000000000000000000
);
```

The field layout is explained [in the source code](https://github.com/latticexyz/mud/blob/main/packages/store/src/FieldLayout.sol#L6-L10).
Here is the interpretation of this value:

| Field                        | Length |  Value | Meaning                     |
| ---------------------------- | -----: | -----: | --------------------------- |
| Length of of static fields   |      2 | 0x0004 | Four bytes of static fields |
| Number of static fields      |      1 |   0x01 | One static field            |
| Number of dynamic fields     |      1 |   0x00 | No dynamic fields           |
| Length of first static field |      1 |   0x04 | ` uint32` is four bytes     |

The field layout is only for the value schema, not the key schema.
The key is not actually written to the storage, it is just used to find the storage slot for the value.

```solidity
library Counter {
  /** Get the table values' field layout */
  function getFieldLayout() internal pure returns (FieldLayout) {
    return _fieldLayout;
  }
```

Return the field layout explained above.

```solidity
/** Get the table's key schema */
function getKeySchema() internal pure returns (Schema) {
  SchemaType[] memory _keySchema = new SchemaType[](0);

  return SchemaLib.encode(_keySchema);
}

/** Get the table's value schema */
function getValueSchema() internal pure returns (Schema) {
  SchemaType[] memory _valueSchema = new SchemaType[](1);
  _valueSchema[0] = SchemaType.UINT32;

  return SchemaLib.encode(_valueSchema);
}
```

These two functions return the schema, the different types of fields, for the value and the key.
In this case, there is nothing in the key because the table only has a single row.

[The list of field types is available here](https://github.com/latticexyz/mud/blob/main/packages/schema-type/src/solidity/SchemaType.sol#L9).

```solidity
/** Get the table's key names */
function getKeyNames() internal pure returns (string[] memory keyNames) {
  keyNames = new string[](0);
}

/** Get the table's field names */
function getFieldNames() internal pure returns (string[] memory fieldNames) {
  fieldNames = new string[](1);
  fieldNames[0] = "value";
}
```

These functions returns the names of the table fields.
`getKeyNames` returns an empty array because there are no fields in the key, this is a singleton.
`getFieldNames` returns one field, `value`.

```solidity
/** Register the table with its config */
function register() internal {
  StoreSwitch.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());
}

/** Register the table with its config */
function _register() internal {
  StoreCore.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());
}

/** Register the table with its config (using the specified store) */
function register(IStore _store) internal {
  _store.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());
}
```

These functions register the schema, either to the default `Store` (`StoreSwitch`) or to one given as a parameter.

```solidity
/** Get value */
function getValue() internal view returns (uint32 value) {
  bytes32[] memory _keyTuple = new bytes32[](0);

  bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
  return (uint32(bytes4(_blob)));
}

/** Get value */
function _getValue() internal view returns (uint32 value) {
  bytes32[] memory _keyTuple = new bytes32[](0);

  bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
  return (uint32(bytes4(_blob)));
}

/** Get value (using the specified store) */
function getValue(IStore _store) internal view returns (uint32 value) {
  bytes32[] memory _keyTuple = new bytes32[](0);

  bytes32 _blob = _store.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
  return (uint32(bytes4(_blob)));
}
```

These getter functions get the value using the field name (`value`).
Because `Counter` is a singleton, the key tuple is empty, and the value is always field zero.

```solidity
/** Get value */
function get() internal view returns (uint32 value) {
  bytes32[] memory _keyTuple = new bytes32[](0);

  bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
  return (uint32(bytes4(_blob)));
}

/** Get value */
function _get() internal view returns (uint32 value) {
  bytes32[] memory _keyTuple = new bytes32[](0);

  bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
  return (uint32(bytes4(_blob)));
}

/** Get value (using the specified store) */
function get(IStore _store) internal view returns (uint32 value) {
  bytes32[] memory _keyTuple = new bytes32[](0);

  bytes32 _blob = _store.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
  return (uint32(bytes4(_blob)));
}
```

These `get` functions return the value.
They are created when there is just one field in the value schema.

Note that we recommend using `get<field>` rather than just `get` because that way you don't have to rewrite code if in a future version you add fields to the table.

```solidity
/** Set value */
function setValue(uint32 value) internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((value)), _fieldLayout);
}

/** Set value */
function _setValue(uint32 value) internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((value)), _fieldLayout);
}

/** Set value (using the specified store) */
function setValue(IStore _store, uint32 value) internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  _store.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((value)), _fieldLayout);
}

/** Set value */
function set(uint32 value) internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((value)), _fieldLayout);
}

/** Set value */
function _set(uint32 value) internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((value)), _fieldLayout);
}

/** Set value (using the specified store) */
function set(IStore _store, uint32 value) internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  _store.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((value)), _fieldLayout);
}
```

These are the setter functions to set the value in various circumstances.

```solidity
/** Delete all data for given keys */
function deleteRecord() internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  StoreSwitch.deleteRecord(_tableId, _keyTuple);
}

/** Delete all data for given keys */
function _deleteRecord() internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);
}

/** Delete all data for given keys (using the specified store) */
function deleteRecord(IStore _store) internal {
  bytes32[] memory _keyTuple = new bytes32[](0);

  _store.deleteRecord(_tableId, _keyTuple);
}
```

These functions delete a record (in this case, that would be the only record).

```solidity
/** Tightly pack static data using this table's schema */
function encodeStatic(uint32 value) internal pure returns (bytes memory) {
  return abi.encodePacked(value);
}

/** Tightly pack full data using this table's field layout */
function encode(uint32 value) internal pure returns (bytes memory, PackedCounter, bytes memory) {
  bytes memory _staticData = encodeStatic(value);

  PackedCounter _encodedLengths;
  bytes memory _dynamicData;

  return (_staticData, _encodedLengths, _dynamicData);
}

/** Encode keys as a bytes32 array using this table's field layout */
function encodeKeyTuple() internal pure returns (bytes32[] memory) {
  bytes32[] memory _keyTuple = new bytes32[](0);

  return _keyTuple;
}
```

Utility functions to encode a value.

</details>

## Logic

The way mud works, onchain logic is implemented by one or more `System`s.
Those systems are typically called by a central `World`,

#### `IncrementSystem.sol`

This is the system that is provided by the demo (`packages/contracts/src/systems/IncrementSystem.sol`).
As the name suggests, it includes a single function that increments `Counter`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import { System } from "@latticexyz/world/src/System.sol";
import { Counter } from "../codegen/index.sol";
```

The system needs to know how to be a `System`, as well as have access to the table (or tables) it needs.

```solidity

contract IncrementSystem is System {
  function increment() public returns (uint32) {
```

There could be multiple functions in the same system, but in this case there is only one, `increment`.

```solidity
    uint32 counter = Counter.get();
```

Read the value. Because `Counter` is a singleton, there are no keys to look up.

```solidity
    uint32 newValue = counter + 1;
    Counter.set(newValue);
```

Update the value.

```solidity
    return newValue;
  }
}
```

Return the new value.

#### `System.sol` and `WorldContext.sol`.

To see what else systems can do, let's look at [`@latticexyz/world/src/System.sol`](https://github.com/latticexyz/mud/blob/main/packages/world/src/System.sol).
At present, all it says is that a `System` is a [`WorldContextConsumer`](https://github.com/latticexyz/mud/blob/main/packages/world/src/WorldContext.sol#L14-L42). This gives us three functions:

That contract has several functions:

```solidity
// Extract the trusted msg.sender value appended to the calldata
function _msgSender() internal view returns (address sender) {
  assembly {
    // 96 = 256 - 20 * 8
    sender := shr(96, calldataload(sub(calldatasize(), 20)))
  }
  if (sender == address(0)) sender = msg.sender;
}
```

Systems are typically called from a `World` contract, so that would typically be `msg.sender`.
To get the user identity and make access control decisions this `World` contract provides its own `msg.sender`
is the last 20 bytes of the calldata.

```solidity
// Extract the trusted msg.value value appended to the calldata
function _msgValue() public pure returns (uint256 value) {
  assembly {
    // Load 32 bytes from calldata at position calldatasize() - 32 bytes,
    value := calldataload(sub(calldatasize(), 32))
  }
}
```

ETH is managed on behalf of `System`s by the `World`.
So if I call has ETH attached as payment for something the value is not propagated to the `System`.
Instead, that value is appended to the calldata and this is how the `System` retrieves it.

```solidity
function _world() internal view returns (address) {
  return StoreSwitch.inferStoreAddress();
}
```

This function gives us the identity of the `World` which called us.
Under certain circumstances the `System` contract is called through [`CALL`](https://mirror.xyz/frimoldi.eth/5RObAeE1sPNeEzyGU9gU0olBtVJqnj0MYkJCVtVNGV0) (in which case the calling `World` is `msg.sender`), and in other cases [`DELEGATECALL`](https://mirror.xyz/frimoldi.eth/5RObAeE1sPNeEzyGU9gU0olBtVJqnj0MYkJCVtVNGV0) (in which case the calling `World` is `address(this)`).

Note that the identity of the world is _not_ specified in the system.
This allows the same `System`, the same application logic, to be shared between multiple different worlds.

```solidity
  // ERC-165 supportsInterface (see https://eips.ethereum.org/EIPS/eip-165)
  function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {
    return interfaceId == WORLD_CONTEXT_CONSUMER_INTERFACE_ID || interfaceId == ERC165_INTERFACE_ID;
  }
}
```

The two interfaces we support, as per [ERC-165](https://eips.ethereum.org/EIPS/eip-165).
